package generator

import (
	"errors"
	"fmt"
	"go/types"
	"io"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Generator struct {
	pkg             *packages.Package
	packageName     string
	targetName      string
	shouldBePointer bool
	writer          io.Writer
}

func New(writer io.Writer, packageName string, targetName string, shouldBePointer bool) (*Generator, error) {
	pkg, err := Load(packageName)
	if err != nil {
		return nil, err
	}
	return &Generator{
		pkg:             pkg,
		packageName:     packageName,
		targetName:      targetName,
		shouldBePointer: shouldBePointer,
		writer:          writer,
	}, nil
}

func (g *Generator) findTarget() *types.TypeName {
	pkg := g.pkg
	for _, n := range pkg.Types.Scope().Names() {
		obj := pkg.Types.Scope().Lookup(n)
		switch obj := obj.(type) {
		case *types.TypeName:
			if obj.Exported() && obj.Name() == g.targetName {
				return obj
			}
		}
	}
	return nil
}

func (g *Generator) getMethods(t types.Type) []*types.Func {
	if g.shouldBePointer {
		return PointerMethods(t)
	}
	return Methods(t)
}

func (g *Generator) Generate() error {
	targetTypeName := g.findTarget()
	if targetTypeName == nil {
		return errors.New("target type is not found")
	}

	methods := g.getMethods(targetTypeName.Type())
	imports := g.collectImports(methods)
	g.writeHeader(imports)
	g.writeStruct(methods)

	for _, m := range methods {
		g.writeAdapterMethod(m)
	}

	return nil
}

func (g *Generator) writeHeader(imports map[string]string) {
	fmt.Fprintln(g, "// Code generated by adapter-gen; DO NOT EDIT.")
	fmt.Fprintln(g, "package adapter") // TODO configurable
	fmt.Fprintln(g)
	imports[extractShortPackage(g.pkg.ID)] = g.pkg.ID
	fmt.Fprintln(g, "import (")
	for _, e := range imports {
		fmt.Fprintf(g, "  \"%s\"\n", e) // TODO consider alias
	}
	fmt.Fprintln(g, ")")
	fmt.Fprintln(g)
}

func (g *Generator) writeStruct(methods []*types.Func) {
	fmt.Fprintln(g, "type "+g.adapterName()+" struct {")
	fmt.Fprintln(g, "  Target "+g.targetType())

	for _, m := range methods {
		methodName := m.Name()
		s, _ := m.Type().(*types.Signature)
		g.writeBeforeHandlerField(methodName, s)
		g.writeAfterHandlerField(methodName, s)
	}

	fmt.Fprintln(g, "}")
	fmt.Fprintln(g)
}

func (g *Generator) writeBeforeHandlerField(methodName string, s *types.Signature) {
	fmt.Fprint(g, "  Before"+methodName+" func(")
	for i := 0; i < s.Params().Len(); i++ {
		p := s.Params().At(i)
		fmt.Fprint(g, ShortTypeString(p.Type()))
		if i != s.Params().Len()-1 {
			fmt.Fprint(g, ", ")
		}
	}
	fmt.Fprint(g, ")")
	fmt.Fprintln(g)
}

func (g *Generator) writeAfterHandlerField(methodName string, s *types.Signature) {
	fmt.Fprint(g, "  After"+methodName+" "+"func(")
	params := []string{}
	for i := 0; i < s.Params().Len(); i++ {
		p := s.Params().At(i)
		params = append(params, ShortTypeString(p.Type()))
	}
	results := []string{}
	for i := 0; i < s.Results().Len(); i++ {
		p := s.Results().At(i)
		results = append(results, ShortTypeString(p.Type()))
	}
	fmt.Fprint(g, strings.Join(append(params, results...), ", "))
	fmt.Fprint(g, ")")
	fmt.Fprintln(g)
}

func (g *Generator) writeAdapterMethod(m *types.Func) {
	methodName := m.Name()
	s, _ := m.Type().(*types.Signature)
	params := []*types.Var{}
	paramNames := []string{}
	for i := 0; i < s.Params().Len(); i++ {
		p := s.Params().At(i)
		params = append(params, p)
		paramNames = append(paramNames, "a"+strconv.Itoa(i))
	}

	resultTypes := []string{}
	for i := 0; i < s.Results().Len(); i++ {
		p := s.Results().At(i)
		resultTypes = append(resultTypes, ShortTypeString(p.Type()))
	}

	fmt.Fprint(g, "func (a *"+g.adapterName()+") "+methodName+"(")
	for i, e := range params {
		fmt.Fprint(g, paramNames[i]+" "+ShortTypeString(e.Type()))
		if i != len(params)-1 {
			fmt.Fprint(g, ", ")
		}
	}
	fmt.Fprintln(g, ") "+"("+strings.Join(resultTypes, ", ")+")"+" {")
	fmt.Fprintln(g, "  a.Before"+methodName+"("+strings.Join(paramNames, ", ")+")")
	fmt.Fprint(g, "  ")
	resultNames := []string{}
	for i := 0; i < s.Results().Len(); i++ {
		resultNames = append(resultNames, "r"+strconv.Itoa(i))
	}
	if len(resultNames) > 0 {
		fmt.Fprintf(g, strings.Join(resultNames, ", ")+" :=")
	}

	fmt.Fprintln(g, "a.Target."+methodName+"("+strings.Join(paramNames, ", ")+")")
	fmt.Fprintln(g, "  a.After"+methodName+"("+strings.Join(append(paramNames, resultNames...), ", ")+")")
	fmt.Fprintln(g, "  return "+strings.Join(resultNames, ", "))

	fmt.Fprintln(g, "}")
	fmt.Fprintln(g)

}

func (g *Generator) collectImports(methods []*types.Func) map[string]string {
	imports := map[string]string{}
	for _, m := range methods {
		s, _ := m.Type().(*types.Signature)
		for i := 0; i < s.Params().Len(); i++ {
			p := s.Params().At(i)
			imports[p.Pkg().Name()] = p.Pkg().Path() // TODO consider cofliction for package name
			// if _, found := imports[p.Pkg().Name()]; found {
			// 	imports[p.Pkg().Name()] = p.Pkg().Path()
			// } else {
			// 	imports[p.Pkg().Name()] = p.Pkg().Path()
			// }
		}
		for i := 0; i < s.Results().Len(); i++ {
			p := s.Results().At(i)
			imports[p.Pkg().Name()] = p.Pkg().Path()
		}

	}
	return imports
}

func (g *Generator) adapterName() string {
	return g.targetName + "Adapter" // TODO configurable
}

func (g *Generator) targetType() string {
	shortPackage := extractShortPackage(g.packageName)
	targetType := shortPackage + "." + g.targetName
	if g.shouldBePointer {
		targetType = "*" + targetType
	}
	return targetType
}

func (g *Generator) Write(p []byte) (n int, err error) {
	return g.writer.Write(p)
}
